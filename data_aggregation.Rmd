---
title: "data_aggregation"
author: "Chunhui Gu"
date: "2024-01-25"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```




```{r}
library(tidyverse)
library(janitor)
```



# 1. Load data
```{r}
samples <- dir('output', full.names=TRUE)
length(samples)
samples[1:5]
```


# combine segments for each sample
```{r}
combined_df <- NULL
for (sample in samples) {
  sampel_name <- basename(sample)
  segments <- dir(sample, full.names=TRUE)
  df <- NULL
  for (segment in segments) {
    df_segment <- read.csv(segment, row.names =1)
    # browser()
    # column bind segments together for each sample for later row sum
    if (is.null(df)) {
      df <- df_segment
    } else {
      df <- bind_cols(df, df_segment)
    }
  }
  # for each sample the count of each gene is the sum of all segments
  row_sums <- apply(df, 1, sum, na.rm=TRUE)
  df <- as.data.frame(row_sums)
  colnames(df) <- sampel_name
  # column bind samples together to get the final df that each column is a sample and each row is a gene
  if (is.null(combined_df)) {
    combined_df <- df
  } else {
    combined_df <- bind_cols(combined_df, df)
  }
}
print(combined_df)
```
```{r}
tail(combined_df)
```

```{r}
# Regular expression to match (e.g., row names containing 'apple')
regex <- "negative"

# Create a logical vector indicating whether each row name matches the regex
matches <- grepl(regex, rownames(combined_df))

# Split the dataframe into two parts
df_match <- combined_df[matches, ]
df_no_match <- combined_df[!matches, ]
```



# Merge counts for genes with subscripts (_1, _2, _3, ..etc) except for neagtive_control
```{r}
merged_df <- df_no_match  %>% 
  rownames_to_column(var = "gene") %>% 
  separate(gene, c("gene", "subscripts"), sep = "_") %>% 
  select(-subscripts) %>%
  group_by(gene) %>% 
  summarise_all(sum) %>% 
  column_to_rownames(var = "gene")
```


add negative control back
```{r}
final_df <- rbind(df_match, merged_df)
```


```{r}
tail(final_df)
```


```{r}
(final_df <- janitor::clean_names(final_df))
```



```{r}
write.csv(final_df, "data/results.csv")
```





```{r}
pheatmap::pheatmap(log2(as.matrix(final_df) + 1), cluster_rows = FALSE, cluster_cols = FALSE, show_rownames = FALSE, show_colnames = TRUE)
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}

```

